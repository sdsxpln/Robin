C51 COMPILER V9.51   UART                                                                  04/26/2015 18:55:47 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN uart.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe uart.c DB OE BR SMALL OPTIMIZE(11,SIZE) DEFINE(SILABS_PLATFORM_WMB912) DEFI
                    -NE(SILABS_WMCU_SI106x) INCDIR(D:\usr\SiLabs\MCU\Inc;D:\usr\cygwin64\home\ticheng\my_repos\robin\inc)

line level    source

   1          /**
   2           *  Copyright 2008 Silicon Laboratories, Inc.
   3           *  http://www.silabs.com
   4           *
   5           *  @file uart.c
   6           *  
   7           *  Source File Description:
   8           *  @brief TODO
   9           *
  10           *  Project Name: EZRADIO SI4X55 EXAMPLES
  11           * 
  12           * 
  13           *  @author Sz. Papp
  14           *
  15           *  @date 2012.08.10.
  16           *
  17           *
  18           *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
  19           *  BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20           *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  21           *  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  22           *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23           *
  24           *  This software must be used in accordance with the End User License Agreement.
  25           */
  26          
  27          /*****************************************************************************
  28           *  Includes
  29           *****************************************************************************/
  30          #include "bsp.h"
  31          
  32          /*****************************************************************************
  33           *  Local variable Declarations
  34           *****************************************************************************/
  35          #ifdef UART_DRIVER_EXTENDED_SUPPORT
  36            volatile SEGMENT_VARIABLE(lUartInternal, tUartData, SEG_XDATA);
  37          #endif
  38          
  39          /*****************************************************************************
  40           *  Local Functions Definition
  41           *****************************************************************************/
  42          
  43          /**
  44           *  Simple UART receive function.
  45           *
  46           * @param[out] byte
  47           *
  48           * @return
  49           *
  50           ******************************************************************************/
  51          U8 Comm_IF_RecvUART(U8 * byte)
  52          {
  53   1      #ifdef UART_DRIVER_EXTENDED_SUPPORT
  54   1        if (lUartInternal.RXReadPosition != lUartInternal.RXWritePosition)
C51 COMPILER V9.51   UART                                                                  04/26/2015 18:55:47 PAGE 2   

  55   1        {
  56   2          *byte = lUartInternal.RXBuffer[lUartInternal.RXReadPosition++];
  57   2      
  58   2          if (lUartInternal.RXReadPosition >= COMM_IF_UART_RX_BUFFER)
  59   2          {
  60   3            lUartInternal.RXReadPosition = 0u;
  61   3          }
  62   2      
  63   2          return TRUE;
  64   2        }
  65   1      
  66   1        return FALSE;
  67   1      #else
                while (!RI0)  ;  /* Wait for RX */
                RI0 = 0;
                *byte = SBUF0;
              
                return TRUE;
              #endif
  74   1      }
  75          
  76          /**
  77           *  Simple UART send function.
  78           *
  79           * @param byte
  80           *
  81           * @return
  82           *
  83           ******************************************************************************/
  84          U8 Comm_IF_SendUART(U8 byte)
  85          {
  86   1      #if 0
              //#ifdef UART_DRIVER_EXTENDED_SUPPORT
                /* Check if buffer is full */
                if ((lUartInternal.TXReadPosition == lUartInternal.TXWritePosition) && (FALSE == lUartInternal.TXBufferE
             -mpty))
                {
                  return FALSE;
                }
              
                /* Write input data byte into buffer */
                lUartInternal.TXBuffer[lUartInternal.TXWritePosition++] = byte;
              
                /* Increment pointer */
                if (lUartInternal.TXWritePosition >= COMM_IF_UART_TX_BUFFER)
                {
                  lUartInternal.TXWritePosition = 0u;
                }
              
                if (TRUE == lUartInternal.TXBufferEmpty)
                {
                  SBUF0 = byte;
                }
              
                lUartInternal.TXBufferEmpty = FALSE;
              //#else
              #endif
 111   1        SBUF0 = byte;
 112   1        while (!TI0)  ; /* Wait until TX */
 113   1        TI0 = 0;
 114   1      //#endif
 115   1      
C51 COMPILER V9.51   UART                                                                  04/26/2015 18:55:47 PAGE 3   

 116   1        return TRUE;
 117   1      }
 118          
 119          /**
 120           *  Enable and set the UART0 peripheral.
 121           *
 122           *  @author Sz. Papp
 123           *
 124           *  @note
 125           *
 126           ******************************************************************************/
 127          void Comm_IF_EnableUART()
 128          {
 129   1        /* Enable UART0 in Crossbar */
 130   1        XBR0 |= 0x01;
 131   1      
 132   1        /* Timer1 Init for UART baud rate */
 133   1        /* the default baud rate is 115200bps */
 134   1        Set115200bps_24MHZ5;
 135   1        TR1   = 1;                /* START Timer1 */
 136   1        TI0   = 1;                /* Transciever ready */
 137   1      
 138   1        /* UART init */
 139   1        SCON0 = 0x10;
 140   1      
 141   1      #ifdef UART_DRIVER_EXTENDED_SUPPORT
 142   1        /* Enable UART0 IT */
 143   1        ES0   = TRUE;
 144   1      
 145   1        lUartInternal.TXBufferEmpty = TRUE;
 146   1      #endif
 147   1      }
 148          
 149          #ifdef UART_DRIVER_EXTENDED_SUPPORT
 150          /**
 151           *  Interrupt handler for UART0 peripheral.
 152           *
 153           *  @author Sz. Papp
 154           *
 155           *  @note   Receive Overrun may occur as it not protected against it yet.
 156           *
 157           *****************************************************************************/
 158          INTERRUPT(UART_ISR, INTERRUPT_UART0)
 159          {
 160   1      #if 0
                if (TI0)
                {
                  /* Transmit Interrupt */
                  TI0 = FALSE;
              
                  lUartInternal.TXReadPosition++;
                  if (lUartInternal.TXReadPosition >= COMM_IF_UART_TX_BUFFER)
                  {
                    lUartInternal.TXReadPosition = 0u;
                  }
              
                  if (lUartInternal.TXReadPosition == lUartInternal.TXWritePosition)
                  {
                    lUartInternal.TXBufferEmpty = TRUE;
                  }
                  else
                  {
C51 COMPILER V9.51   UART                                                                  04/26/2015 18:55:47 PAGE 4   

                    SBUF0 = lUartInternal.TXBuffer[lUartInternal.TXReadPosition];
                  }
                }
              #endif
 182   1        if (RI0)
 183   1        {
 184   2          /* Receive Interrupt */
 185   2          RI0 = FALSE;
 186   2      
 187   2          lUartInternal.RXBuffer[lUartInternal.RXWritePosition++] = SBUF0;
 188   2      
 189   2          if (lUartInternal.RXWritePosition >= COMM_IF_UART_RX_BUFFER)
 190   2          {
 191   3            lUartInternal.RXWritePosition = 0u;
 192   3          }
 193   2        }
 194   1      }
 195          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    148    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   3005    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
