C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE SI446X_API_LIB
OBJECT MODULE PLACED IN si446x_api_lib.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe si446x_api_lib.c DB OE BR SMALL OPTIMIZE(11,SIZE) DEFINE(SILABS_PLATFORM_WM
                    -B912) DEFINE(SILABS_WMCU_SI106x) INCDIR(D:\usr\SiLabs\MCU\Inc;D:\usr\cygwin64\home\ticheng\my_repos\robin\inc)

line level    source

   1          /*!
   2           * File:
   3           *  si446x_api_lib.c
   4           *
   5           * Description:
   6           *  This file contains the Si446x API library.
   7           *
   8           * Silicon Laboratories Confidential
   9           * Copyright 2011 Silicon Laboratories, Inc.
  10           */
  11          
  12          #include "bsp.h"
  13          #include <stdarg.h>
  14          
  15          SEGMENT_VARIABLE( Si446xCmd, union si446x_cmd_reply_union, SEG_XDATA );
  16          SEGMENT_VARIABLE( Pro2Cmd[16], U8, SEG_XDATA );
  17          
  18          #ifdef SI446X_PATCH_CMDS
              SEGMENT_VARIABLE( Si446xPatchCommands[][8] = { SI446X_PATCH_CMDS }, U8, SEG_CODE);
              #endif
  21          
  22          
  23          /*!
  24           * This functions is used to reset the si446x radio by applying shutdown and
  25           * releasing it.  After this function @ref si446x_boot should be called.  You
  26           * can check if POR has completed by waiting 4 ms or by polling GPIO 0, 2, or 3.
  27           * When these GPIOs are high, it is safe to call @ref si446x_boot.
  28           */
  29          void si446x_reset(void)
  30          {
  31   1          U8 loopCount;
  32   1      
  33   1          /* Put radio in shutdown, wait then release */
  34   1          radio_hal_AssertShutdown();
  35   1          //! @todo this needs to be a better delay function.
  36   1          for (loopCount = 255; loopCount != 0; loopCount--);
  37   1          radio_hal_DeassertShutdown();
  38   1          for (loopCount = 255; loopCount != 0; loopCount--);
  39   1          radio_comm_ClearCTS();
  40   1      }
  41          
  42          /*!
  43           * This function is used to initialize after power-up the radio chip.
  44           * Before this function @si446x_reset should be called.
  45           */
  46          void si446x_power_up(U8 BOOT_OPTIONS, U8 XTAL_OPTIONS, U32 XO_FREQ)
  47          {
  48   1          Pro2Cmd[0] = SI446X_CMD_ID_POWER_UP;
  49   1          Pro2Cmd[1] = BOOT_OPTIONS;
  50   1          Pro2Cmd[2] = XTAL_OPTIONS;
  51   1          Pro2Cmd[3] = (U8)(XO_FREQ >> 24);
  52   1          Pro2Cmd[4] = (U8)(XO_FREQ >> 16);
  53   1          Pro2Cmd[5] = (U8)(XO_FREQ >> 8);
  54   1          Pro2Cmd[6] = (U8)(XO_FREQ);
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 2   

  55   1      
  56   1          radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_POWER_UP, Pro2Cmd );
  57   1      }
  58          
  59          /*!
  60           * This function is used to load all properties and commands with a list of NULL terminated commands.
  61           * Before this function @si446x_reset should be called.
  62           */
  63          U8 si446x_configuration_init(const U8* pSetPropCmd)
  64          {
  65   1        SEGMENT_VARIABLE(col, U8, SEG_DATA);
  66   1        SEGMENT_VARIABLE(numOfBytes, U8, SEG_DATA);
  67   1      
  68   1        /* While cycle as far as the pointer points to a command */
  69   1        while (*pSetPropCmd != 0x00)
  70   1        {
  71   2          /* Commands structure in the array:
  72   2           * --------------------------------
  73   2           * LEN | <LEN length of data>
  74   2           */
  75   2      
  76   2          numOfBytes = *pSetPropCmd++;
  77   2      
  78   2          if (numOfBytes > 16u)
  79   2          {
  80   3            /* Number of command bytes exceeds maximal allowable length */
  81   3            return SI446X_COMMAND_ERROR;
  82   3          }
  83   2      
  84   2          for (col = 0u; col < numOfBytes; col++)
  85   2          {
  86   3            Pro2Cmd[col] = *pSetPropCmd;
  87   3            pSetPropCmd++;
  88   3          }
  89   2      
  90   2          if (radio_comm_SendCmdGetResp(numOfBytes, Pro2Cmd, 0, 0) != 0xFF)
  91   2          {
  92   3            /* Timeout occured */
  93   3            return SI446X_CTS_TIMEOUT;
  94   3          }
  95   2      
  96   2          if (radio_hal_NirqLevel() == 0)
  97   2          {
  98   3            /* Get and clear all interrupts.  An error has occured... */
  99   3            si446x_get_int_status(0, 0, 0);
 100   3            if (Si446xCmd.GET_INT_STATUS.CHIP_PEND & SI446X_CMD_GET_CHIP_STATUS_REP_CMD_ERROR_PEND_MASK)
 101   3            {
 102   4              return SI446X_COMMAND_ERROR;
 103   4            }
 104   3          }
 105   2        }
 106   1      
 107   1        return SI446X_SUCCESS;
 108   1      }
 109          
 110          /*!
 111           * This function is used to apply a firmware patch to the si446x radio.  This
 112           * patch is stored in code using the si446x_patch.h file.
 113           *
 114           * @return  SI446X_CTS_TIMEOUT If a CTS error occurs.
 115           *          SI446X_PATCH_FAIL If the patch fails.
 116           *          SI446X_SUCCESS If the patch is successful.
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 3   

 117           *          SI446X_NO_PATCH If there is no patch in the Flash to load.
 118           */
 119          U8 si446x_apply_patch(void)
 120          {
 121   1      #ifdef SI446X_PATCH_CMDS
                  SEGMENT_VARIABLE(line, U16, SEG_DATA);
                  SEGMENT_VARIABLE(row,  U8, SEG_DATA);
              
                  /* Check if patch is needed. */
                  si446x_part_info();
              
                  if ((Si446xCmd.PART_INFO.ROMID == SI446X_PATCH_ROMID) && (Si446xCmd.PART_INFO.ID.U8[MSB] < SI446X_PATC
             -H_ID))
                  {
                    for (line = 0; line < (sizeof(Si446xPatchCommands) / 8u); line++)
                    {
                      for (row=0; row<8; row++)
                      {
                        Pro2Cmd[row] = Si446xPatchCommands[line][row];
                      }
                      if (radio_comm_SendCmdGetResp(8, Pro2Cmd, 0, 0) != 0xFF)
                      {
                        // Timeout occured
                        return SI446X_CTS_TIMEOUT;
                      }
                      if (radio_hal_NirqLevel() == 0)
                      {
                        /* Get and clear all interrupts.  An error has occured... */
                        si446x_get_int_status(0, 0, 0);
                        return SI446X_PATCH_FAIL;
                      }
                    }
                  }
              
                  return SI446X_SUCCESS;
              #else
 152   1          return SI446X_NO_PATCH;
 153   1      #endif
 154   1      }
 155          
 156          /*! This function sends the PART_INFO command to the radio and receives the answer
 157           *  into @Si446xCmd union.
 158           */
 159          void si446x_part_info(void)
 160          {
 161   1          Pro2Cmd[0] = SI446X_CMD_ID_PART_INFO;
 162   1      
 163   1          radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_PART_INFO,
 164   1                                    Pro2Cmd,
 165   1                                    SI446X_CMD_REPLY_COUNT_PART_INFO,
 166   1                                    Pro2Cmd );
 167   1      
 168   1          Si446xCmd.PART_INFO.CHIPREV         = Pro2Cmd[0];
 169   1          Si446xCmd.PART_INFO.PART.U8[MSB]    = Pro2Cmd[1];
 170   1          Si446xCmd.PART_INFO.PART.U8[LSB]    = Pro2Cmd[2];
 171   1          Si446xCmd.PART_INFO.PBUILD          = Pro2Cmd[3];
 172   1          Si446xCmd.PART_INFO.ID.U8[MSB]      = Pro2Cmd[4];
 173   1          Si446xCmd.PART_INFO.ID.U8[LSB]      = Pro2Cmd[5];
 174   1          Si446xCmd.PART_INFO.CUSTOMER        = Pro2Cmd[6];
 175   1          Si446xCmd.PART_INFO.ROMID           = Pro2Cmd[7];
 176   1      }
 177          
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 4   

 178          /*! Sends START_TX command to the radio.
 179           *
 180           * @param CHANNEL   Channel number.
 181           * @param CONDITION Start TX condition.
 182           * @param TX_LEN    Payload length (exclude the PH generated CRC).
 183           */
 184          void si446x_start_tx(U8 CHANNEL, U8 CONDITION, U16 TX_LEN)
 185          {
 186   1          Pro2Cmd[0] = SI446X_CMD_ID_START_TX;
 187   1          Pro2Cmd[1] = CHANNEL;
 188   1          Pro2Cmd[2] = CONDITION;
 189   1          Pro2Cmd[3] = (U8)(TX_LEN >> 8);
 190   1          Pro2Cmd[4] = (U8)(TX_LEN);
 191   1          Pro2Cmd[5] = 0x00;
 192   1      
 193   1          radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_START_TX, Pro2Cmd );
 194   1      }
 195          
 196          /*!
 197           * Sends START_RX command to the radio.
 198           *
 199           * @param CHANNEL     Channel number.
 200           * @param CONDITION   Start RX condition.
 201           * @param RX_LEN      Payload length (exclude the PH generated CRC).
 202           * @param NEXT_STATE1 Next state when Preamble Timeout occurs.
 203           * @param NEXT_STATE2 Next state when a valid packet received.
 204           * @param NEXT_STATE3 Next state when invalid packet received (e.g. CRC error).
 205           */
 206          void si446x_start_rx(U8 CHANNEL, U8 CONDITION, U16 RX_LEN, U8 NEXT_STATE1, U8 NEXT_STATE2, U8 NEXT_STATE3)
 207          {
 208   1          Pro2Cmd[0] = SI446X_CMD_ID_START_RX;
 209   1          Pro2Cmd[1] = CHANNEL;
 210   1          Pro2Cmd[2] = CONDITION;
 211   1          Pro2Cmd[3] = (U8)(RX_LEN >> 8);
 212   1          Pro2Cmd[4] = (U8)(RX_LEN);
 213   1          Pro2Cmd[5] = NEXT_STATE1;
 214   1          Pro2Cmd[6] = NEXT_STATE2;
 215   1          Pro2Cmd[7] = NEXT_STATE3;
 216   1      
 217   1          radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_START_RX, Pro2Cmd );
 218   1      }
 219          
 220          /*!
 221           * Get the Interrupt status/pending flags form the radio and clear flags if requested.
 222           *
 223           * @param PH_CLR_PEND     Packet Handler pending flags clear.
 224           * @param MODEM_CLR_PEND  Modem Status pending flags clear.
 225           * @param CHIP_CLR_PEND   Chip State pending flags clear.
 226           */
 227          void si446x_get_int_status(U8 PH_CLR_PEND, U8 MODEM_CLR_PEND, U8 CHIP_CLR_PEND)
 228          {
 229   1          Pro2Cmd[0] = SI446X_CMD_ID_GET_INT_STATUS;
 230   1          Pro2Cmd[1] = PH_CLR_PEND;
 231   1          Pro2Cmd[2] = MODEM_CLR_PEND;
 232   1          Pro2Cmd[3] = CHIP_CLR_PEND;
 233   1      
 234   1          radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_INT_STATUS,
 235   1                                    Pro2Cmd,
 236   1                                    SI446X_CMD_REPLY_COUNT_GET_INT_STATUS,
 237   1                                    Pro2Cmd );
 238   1      
 239   1          Si446xCmd.GET_INT_STATUS.INT_PEND       = Pro2Cmd[0];
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 5   

 240   1          Si446xCmd.GET_INT_STATUS.INT_STATUS     = Pro2Cmd[1];
 241   1          Si446xCmd.GET_INT_STATUS.PH_PEND        = Pro2Cmd[2];
 242   1          Si446xCmd.GET_INT_STATUS.PH_STATUS      = Pro2Cmd[3];
 243   1          Si446xCmd.GET_INT_STATUS.MODEM_PEND     = Pro2Cmd[4];
 244   1          Si446xCmd.GET_INT_STATUS.MODEM_STATUS   = Pro2Cmd[5];
 245   1          Si446xCmd.GET_INT_STATUS.CHIP_PEND      = Pro2Cmd[6];
 246   1          Si446xCmd.GET_INT_STATUS.CHIP_STATUS    = Pro2Cmd[7];
 247   1      }
 248          
 249          /*!
 250           * Send GPIO pin config command to the radio and reads the answer into
 251           * @Si446xCmd union.
 252           *
 253           * @param GPIO0       GPIO0 configuration.
 254           * @param GPIO1       GPIO1 configuration.
 255           * @param GPIO2       GPIO2 configuration.
 256           * @param GPIO3       GPIO3 configuration.
 257           * @param NIRQ        NIRQ configuration.
 258           * @param SDO         SDO configuration.
 259           * @param GEN_CONFIG  General pin configuration.
 260           */
 261          void si446x_gpio_pin_cfg(U8 GPIO0, U8 GPIO1, U8 GPIO2, U8 GPIO3, U8 NIRQ, U8 SDO, U8 GEN_CONFIG)
 262          {
 263   1          Pro2Cmd[0] = SI446X_CMD_ID_GPIO_PIN_CFG;
 264   1          Pro2Cmd[1] = GPIO0;
 265   1          Pro2Cmd[2] = GPIO1;
 266   1          Pro2Cmd[3] = GPIO2;
 267   1          Pro2Cmd[4] = GPIO3;
 268   1          Pro2Cmd[5] = NIRQ;
 269   1          Pro2Cmd[6] = SDO;
 270   1          Pro2Cmd[7] = GEN_CONFIG;
 271   1      
 272   1          radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GPIO_PIN_CFG,
 273   1                                    Pro2Cmd,
 274   1                                    SI446X_CMD_REPLY_COUNT_GPIO_PIN_CFG,
 275   1                                    Pro2Cmd );
 276   1      
 277   1          Si446xCmd.GPIO_PIN_CFG.GPIO0        = Pro2Cmd[0];
 278   1          Si446xCmd.GPIO_PIN_CFG.GPIO1        = Pro2Cmd[1];
 279   1          Si446xCmd.GPIO_PIN_CFG.GPIO2        = Pro2Cmd[2];
 280   1          Si446xCmd.GPIO_PIN_CFG.GPIO3        = Pro2Cmd[3];
 281   1          Si446xCmd.GPIO_PIN_CFG.NIRQ         = Pro2Cmd[4];
 282   1          Si446xCmd.GPIO_PIN_CFG.SDO          = Pro2Cmd[5];
 283   1          Si446xCmd.GPIO_PIN_CFG.GEN_CONFIG   = Pro2Cmd[6];
 284   1      }
 285          
 286          /*!
 287           * Send SET_PROPERTY command to the radio.
 288           *
 289           * @param GROUP       Property group.
 290           * @param NUM_PROPS   Number of property to be set. The properties must be in ascending order
 291           *                    in their sub-property aspect. Max. 12 properties can be set in one command.
 292           * @param START_PROP  Start sub-property address.
 293           */
 294          #ifdef __C51__
 295          #pragma maxargs (13)  /* allow 13 bytes for parameters */
 296          #endif
 297          void si446x_set_property( U8 GROUP, U8 NUM_PROPS, U8 START_PROP, ... )
 298          {
 299   1          va_list argList;
 300   1          U8 cmdIndex;
 301   1      
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 6   

 302   1          Pro2Cmd[0] = SI446X_CMD_ID_SET_PROPERTY;
 303   1          Pro2Cmd[1] = GROUP;
 304   1          Pro2Cmd[2] = NUM_PROPS;
 305   1          Pro2Cmd[3] = START_PROP;
 306   1      
 307   1          va_start (argList, START_PROP);
 308   1          cmdIndex = 4;
 309   1          while(NUM_PROPS--)
 310   1          {
 311   2              Pro2Cmd[cmdIndex] = va_arg (argList, U8);
 312   2              cmdIndex++;
 313   2          }
 314   1          va_end(argList);
 315   1      
 316   1          radio_comm_SendCmd( cmdIndex, Pro2Cmd );
 317   1      }
 318          
 319          /*!
 320           * Issue a change state command to the radio.
 321           *
 322           * @param NEXT_STATE1 Next state.
 323           */
 324          void si446x_change_state(U8 NEXT_STATE1)
 325          {
 326   1          Pro2Cmd[0] = SI446X_CMD_ID_CHANGE_STATE;
 327   1          Pro2Cmd[1] = NEXT_STATE1;
 328   1      
 329   1          radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_CHANGE_STATE, Pro2Cmd );
 330   1      }
 331          
 332          
 333          /* Extended driver support functions */
 334          /*!
 335           * Sends NOP command to the radio. Can be used to maintain SPI communication.
 336           */
 337          void si446x_nop(void)
 338          {
 339   1          Pro2Cmd[0] = SI446X_CMD_ID_NOP;
 340   1      
 341   1          radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_NOP, Pro2Cmd );
 342   1      }
 343          
 344          /*!
 345           * Send the FIFO_INFO command to the radio. Optionally resets the TX/RX FIFO. Reads the radio response bac
             -k
 346           * into @Si446xCmd.
 347           *
 348           * @param FIFO  RX/TX FIFO reset flags.
 349           */
 350          void si446x_fifo_info(U8 FIFO)
 351          {
 352   1          Pro2Cmd[0] = SI446X_CMD_ID_FIFO_INFO;
 353   1          Pro2Cmd[1] = FIFO;
 354   1      
 355   1          radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_FIFO_INFO,
 356   1                                    Pro2Cmd,
 357   1                                    SI446X_CMD_REPLY_COUNT_FIFO_INFO,
 358   1                                    Pro2Cmd );
 359   1      
 360   1          Si446xCmd.FIFO_INFO.RX_FIFO_COUNT   = Pro2Cmd[0];
 361   1          Si446xCmd.FIFO_INFO.TX_FIFO_SPACE   = Pro2Cmd[1];
 362   1      }
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 7   

 363          
 364          /*!
 365           * The function can be used to load data into TX FIFO.
 366           *
 367           * @param numBytes  Data length to be load.
 368           * @param pTxData   Pointer to the data (U8*).
 369           */
 370          void si446x_write_tx_fifo(U8 numBytes, U8* pTxData)
 371          {
 372   1        radio_comm_WriteData( SI446X_CMD_ID_WRITE_TX_FIFO, 0, numBytes, pTxData );
 373   1      }
 374          
 375          /*!
 376           * Reads the RX FIFO content from the radio.
 377           *
 378           * @param numBytes  Data length to be read.
 379           * @param pRxData   Pointer to the buffer location.
 380           */
 381          void si446x_read_rx_fifo(U8 numBytes, U8* pRxData)
 382          {
 383   1        radio_comm_ReadData( SI446X_CMD_ID_READ_RX_FIFO, 0, numBytes, pRxData );
 384   1      }
 385          #ifdef RADIO_DRIVER_EXTENDED_SUPPORT
              
              /*!
               * Get property values from the radio. Reads them into Si446xCmd union.
               *
               * @param GROUP       Property group number.
               * @param NUM_PROPS   Number of properties to be read.
               * @param START_PROP  Starting sub-property number.
               */
              void si446x_get_property(U8 GROUP, U8 NUM_PROPS, U8 START_PROP)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_GET_PROPERTY;
                  Pro2Cmd[1] = GROUP;
                  Pro2Cmd[2] = NUM_PROPS;
                  Pro2Cmd[3] = START_PROP;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_PROPERTY,
                                            Pro2Cmd,
                                            Pro2Cmd[2],
                                            Pro2Cmd );
              
                  Si446xCmd.GET_PROPERTY.DATA0    = Pro2Cmd[0];
                  Si446xCmd.GET_PROPERTY.DATA1    = Pro2Cmd[1];
                  Si446xCmd.GET_PROPERTY.DATA2    = Pro2Cmd[2];
                  Si446xCmd.GET_PROPERTY.DATA3    = Pro2Cmd[3];
                  Si446xCmd.GET_PROPERTY.DATA4    = Pro2Cmd[4];
                  Si446xCmd.GET_PROPERTY.DATA5    = Pro2Cmd[5];
                  Si446xCmd.GET_PROPERTY.DATA6    = Pro2Cmd[6];
                  Si446xCmd.GET_PROPERTY.DATA7    = Pro2Cmd[7];
                  Si446xCmd.GET_PROPERTY.DATA8    = Pro2Cmd[8];
                  Si446xCmd.GET_PROPERTY.DATA9    = Pro2Cmd[9];
                  Si446xCmd.GET_PROPERTY.DATA10   = Pro2Cmd[10];
                  Si446xCmd.GET_PROPERTY.DATA11   = Pro2Cmd[11];
                  Si446xCmd.GET_PROPERTY.DATA12   = Pro2Cmd[12];
                  Si446xCmd.GET_PROPERTY.DATA13   = Pro2Cmd[13];
                  Si446xCmd.GET_PROPERTY.DATA14   = Pro2Cmd[14];
                  Si446xCmd.GET_PROPERTY.DATA15   = Pro2Cmd[15];
              }
              
              
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 8   

              #ifdef RADIO_DRIVER_FULL_SUPPORT
              /* Full driver support functions */
              
              /*!
               * Sends the FUNC_INFO command to the radio, then reads the resonse into @Si446xCmd union.
               */
              void si446x_func_info(void)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_FUNC_INFO;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_FUNC_INFO,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_FUNC_INFO,
                                            Pro2Cmd );
              
                  Si446xCmd.FUNC_INFO.REVEXT          = Pro2Cmd[0];
                  Si446xCmd.FUNC_INFO.REVBRANCH       = Pro2Cmd[1];
                  Si446xCmd.FUNC_INFO.REVINT          = Pro2Cmd[2];
                  Si446xCmd.FUNC_INFO.PATCH.U8[MSB]   = Pro2Cmd[3];
                  Si446xCmd.FUNC_INFO.PATCH.U8[LSB]   = Pro2Cmd[4];
                  Si446xCmd.FUNC_INFO.FUNC            = Pro2Cmd[5];
              }
              
              /*!
               * Reads the Fast Response Registers starting with A register into @Si446xCmd union.
               *
               * @param respByteCount Number of Fast Response Registers to be read.
               */
              void si446x_frr_a_read(U8 respByteCount)
              {
                  radio_comm_ReadData(SI446X_CMD_ID_FRR_A_READ,
                                          0,
                                      respByteCount,
                                      Pro2Cmd);
              
                  Si446xCmd.FRR_A_READ.FRR_A_VALUE = Pro2Cmd[0];
                  Si446xCmd.FRR_A_READ.FRR_B_VALUE = Pro2Cmd[1];
                  Si446xCmd.FRR_A_READ.FRR_C_VALUE = Pro2Cmd[2];
                  Si446xCmd.FRR_A_READ.FRR_D_VALUE = Pro2Cmd[3];
              }
              
              /*!
               * Reads the Fast Response Registers starting with B register into @Si446xCmd union.
               *
               * @param respByteCount Number of Fast Response Registers to be read.
               */
              void si446x_frr_b_read(U8 respByteCount)
              {
                  radio_comm_ReadData(SI446X_CMD_ID_FRR_B_READ,
                                          0,
                                      respByteCount,
                                      Pro2Cmd);
              
                  Si446xCmd.FRR_B_READ.FRR_B_VALUE = Pro2Cmd[0];
                  Si446xCmd.FRR_B_READ.FRR_C_VALUE = Pro2Cmd[1];
                  Si446xCmd.FRR_B_READ.FRR_D_VALUE = Pro2Cmd[2];
                  Si446xCmd.FRR_B_READ.FRR_A_VALUE = Pro2Cmd[3];
              }
              
              /*!
               * Reads the Fast Response Registers starting with C register into @Si446xCmd union.
               *
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 9   

               * @param respByteCount Number of Fast Response Registers to be read.
               */
              void si446x_frr_c_read(U8 respByteCount)
              {
                  radio_comm_ReadData(SI446X_CMD_ID_FRR_C_READ,
                                          0,
                                      respByteCount,
                                      Pro2Cmd);
              
                  Si446xCmd.FRR_C_READ.FRR_C_VALUE = Pro2Cmd[0];
                  Si446xCmd.FRR_C_READ.FRR_D_VALUE = Pro2Cmd[1];
                  Si446xCmd.FRR_C_READ.FRR_A_VALUE = Pro2Cmd[2];
                  Si446xCmd.FRR_C_READ.FRR_B_VALUE = Pro2Cmd[3];
              }
              
              /*!
               * Reads the Fast Response Registers starting with D register into @Si446xCmd union.
               *
               * @param respByteCount Number of Fast Response Registers to be read.
               */
              void si446x_frr_d_read(U8 respByteCount)
              {
                  radio_comm_ReadData(SI446X_CMD_ID_FRR_D_READ,
                                          0,
                                      respByteCount,
                                      Pro2Cmd);
              
                  Si446xCmd.FRR_D_READ.FRR_D_VALUE = Pro2Cmd[0];
                  Si446xCmd.FRR_D_READ.FRR_A_VALUE = Pro2Cmd[1];
                  Si446xCmd.FRR_D_READ.FRR_B_VALUE = Pro2Cmd[2];
                  Si446xCmd.FRR_D_READ.FRR_C_VALUE = Pro2Cmd[3];
              }
              
              /*!
               * Reads the ADC values from the radio into @Si446xCmd union.
               *
               * @param ADC_EN  ADC enable parameter.
               */
              void si446x_get_adc_reading(U8 ADC_EN)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_GET_ADC_READING;
                  Pro2Cmd[1] = ADC_EN;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_ADC_READING,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_GET_ADC_READING,
                                            Pro2Cmd );
              
                  Si446xCmd.GET_ADC_READING.GPIO_ADC.U8[MSB]      = Pro2Cmd[0];
                  Si446xCmd.GET_ADC_READING.GPIO_ADC.U8[LSB]      = Pro2Cmd[1];
                  Si446xCmd.GET_ADC_READING.BATTERY_ADC.U8[MSB]   = Pro2Cmd[2];
                  Si446xCmd.GET_ADC_READING.BATTERY_ADC.U8[LSB]   = Pro2Cmd[3];
                  Si446xCmd.GET_ADC_READING.TEMP_ADC.U8[MSB]      = Pro2Cmd[4];
                  Si446xCmd.GET_ADC_READING.TEMP_ADC.U8[LSB]      = Pro2Cmd[5];
                  Si446xCmd.GET_ADC_READING.TEMP_SLOPE            = Pro2Cmd[6];
                  Si446xCmd.GET_ADC_READING.TEMP_INTERCEPT        = Pro2Cmd[7];
              }
              
              /*!
               * Receives information from the radio of the current packet. Optionally can be used to modify
               * the Packet Handler properties during packet reception.
               *
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 10  

               * @param FIELD_NUMBER_MASK Packet Field number mask value.
               * @param LEN               Length value.
               * @param DIFF_LEN          Difference length.
               */
              void si446x_get_packet_info(U8 FIELD_NUMBER_MASK, U16 LEN, S16 DIFF_LEN )
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_PACKET_INFO;
                  Pro2Cmd[1] = FIELD_NUMBER_MASK;
                  Pro2Cmd[2] = (U8)(LEN >> 8);
                  Pro2Cmd[3] = (U8)(LEN);
                  // the different of the byte, althrough it is signed, but to command hander
                  // it can treat it as unsigned
                  Pro2Cmd[4] = (U8)((U16)DIFF_LEN >> 8);
                  Pro2Cmd[5] = (U8)(DIFF_LEN);
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_PACKET_INFO,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_PACKET_INFO,
                                            Pro2Cmd );
              
                  Si446xCmd.PACKET_INFO.LENGTH_15_8   = Pro2Cmd[0];
                  Si446xCmd.PACKET_INFO.LENGTH_7_0    = Pro2Cmd[1];
              }
              
              /*!
               * Gets the Packet Handler status flags. Optionally clears them.
               *
               * @param PH_CLR_PEND Flags to clear.
               */
              void si446x_get_ph_status(U8 PH_CLR_PEND)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_GET_PH_STATUS;
                  Pro2Cmd[1] = PH_CLR_PEND;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_PH_STATUS,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_GET_PH_STATUS,
                                            Pro2Cmd );
              
                  Si446xCmd.GET_PH_STATUS.PH_PEND        = Pro2Cmd[0];
                  Si446xCmd.GET_PH_STATUS.PH_STATUS      = Pro2Cmd[1];
              }
              
              /*!
               * Gets the Modem status flags. Optionally clears them.
               *
               * @param MODEM_CLR_PEND Flags to clear.
               */
              void si446x_get_modem_status( U8 MODEM_CLR_PEND )
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_GET_MODEM_STATUS;
                  Pro2Cmd[1] = MODEM_CLR_PEND;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_MODEM_STATUS,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_GET_MODEM_STATUS,
                                            Pro2Cmd );
              
                  Si446xCmd.GET_MODEM_STATUS.MODEM_PEND   = Pro2Cmd[0];
                  Si446xCmd.GET_MODEM_STATUS.MODEM_STATUS = Pro2Cmd[1];
                  Si446xCmd.GET_MODEM_STATUS.CURR_RSSI    = Pro2Cmd[2];
                  Si446xCmd.GET_MODEM_STATUS.LATCH_RSSI   = Pro2Cmd[3];
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 11  

                  Si446xCmd.GET_MODEM_STATUS.ANT1_RSSI    = Pro2Cmd[4];
                  Si446xCmd.GET_MODEM_STATUS.ANT2_RSSI    = Pro2Cmd[5];
                  Si446xCmd.GET_MODEM_STATUS.AFC_FREQ_OFFSET.U8[MSB]  = Pro2Cmd[6];
                  Si446xCmd.GET_MODEM_STATUS.AFC_FREQ_OFFSET.U8[LSB]  = Pro2Cmd[7];
              }
              
              /*!
               * Gets the Chip status flags. Optionally clears them.
               *
               * @param CHIP_CLR_PEND Flags to clear.
               */
              void si446x_get_chip_status( U8 CHIP_CLR_PEND )
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_GET_CHIP_STATUS;
                  Pro2Cmd[1] = CHIP_CLR_PEND;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_GET_CHIP_STATUS,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_GET_CHIP_STATUS,
                                            Pro2Cmd );
              
                  Si446xCmd.GET_CHIP_STATUS.CHIP_PEND         = Pro2Cmd[0];
                  Si446xCmd.GET_CHIP_STATUS.CHIP_STATUS       = Pro2Cmd[1];
                  Si446xCmd.GET_CHIP_STATUS.CMD_ERR_STATUS    = Pro2Cmd[2];
              }
              
              /*!
               * Performs image rejection calibration. Completion can be monitored by polling CTS or waiting for CHIP_RE
             -ADY interrupt source.
               *
               * @param SEARCHING_STEP_SIZE
               * @param SEARCHING_RSSI_AVG
               * @param RX_CHAIN_SETTING1
               * @param RX_CHAIN_SETTING2
               */
              void si446x_ircal(U8 SEARCHING_STEP_SIZE, U8 SEARCHING_RSSI_AVG, U8 RX_CHAIN_SETTING1, U8 RX_CHAIN_SETTING
             -2)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_IRCAL;
                  Pro2Cmd[1] = SEARCHING_STEP_SIZE;
                  Pro2Cmd[2] = SEARCHING_RSSI_AVG;
                  Pro2Cmd[3] = RX_CHAIN_SETTING1;
                  Pro2Cmd[4] = RX_CHAIN_SETTING2;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_IRCAL,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_IRCAL,
                                            Pro2Cmd );
              
                  Si446xCmd.IRCAL.CAL_STATE   = Pro2Cmd[0];
                  Si446xCmd.IRCAL.RSSI        = Pro2Cmd[1];
                  Si446xCmd.IRCAL.DIR_CH      = Pro2Cmd[2];
              }
              
              /*!
               * Sets the chip up for specified protocol.
               *
               * @param PROTOCOL    0 = Packet format is generic, no dynamic reprogramming of packet handler properties.
                                    1 = Packet format is IEEE802.15.4g compliant. The following properties are overriden
             -:
                                    PKT_CRC_CONFIG, CRC_ENDIAN/BIT_ORDER in PKT_CONFG1 for TX and RX, PKT_FIELD_1_CRC_CO
             -NFIG for RX.
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 12  

                                    Other applicable properties in the packet handler group still need to be programmed.
             - Field 1 should
                                    have the length of 16 bits to contain the PHR with PKT_LEN_FIELD_SOURCE set to 1 for
             - RX. PSDU field
                                    shall use Field 2 with variable length. Field 2 length should be set to the maximum 
             -allowed including
                                    the anticipated FCS length. It is anticipated that the FCS will be calculated by the
             - host and transmitted
                                    over the air. Si4440 will receive PHR and put FCS in the FIFO for the host to retrie
             -ve and check.
                                    Therefore, CRC shouldn't be enabled on Si4440.
               */
              void si446x_protocol_cfg(U8 PROTOCOL)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_PROTOCOL_CFG;
                  Pro2Cmd[1] = PROTOCOL;
              
                  radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_PROTOCOL_CFG, Pro2Cmd );
              }
              
              /*!
               * Requests the current state of the device and lists pending TX and RX requests
               */
              void si446x_request_device_state(void)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_REQUEST_DEVICE_STATE;
              
                  radio_comm_SendCmdGetResp( SI446X_CMD_ARG_COUNT_REQUEST_DEVICE_STATE,
                                            Pro2Cmd,
                                            SI446X_CMD_REPLY_COUNT_REQUEST_DEVICE_STATE,
                                            Pro2Cmd );
              
                  Si446xCmd.REQUEST_DEVICE_STATE.CURR_STATE       = Pro2Cmd[0];
                  Si446xCmd.REQUEST_DEVICE_STATE.CURRENT_CHANNEL  = Pro2Cmd[1];
              }
              
              /*!
               * While in RX state this will hop to the frequency specified by the parameters and start searching for a 
             -preamble.
               *
               * @param INTE      New INTE register value.
               * @param FRAC2     New FRAC2 register value.
               * @param FRAC1     New FRAC1 register value.
               * @param FRAC0     New FRAC0 register value.
               * @param VCO_CNT1  New VCO_CNT1 register value.
               * @param VCO_CNT0  New VCO_CNT0 register value.
               */
              void si446x_rx_hop(U8 INTE, U8 FRAC2, U8 FRAC1, U8 FRAC0, U8 VCO_CNT1, U8 VCO_CNT0)
              {
                  Pro2Cmd[0] = SI446X_CMD_ID_RX_HOP;
                  Pro2Cmd[1] = INTE;
                  Pro2Cmd[2] = FRAC2;
                  Pro2Cmd[3] = FRAC1;
                  Pro2Cmd[4] = FRAC0;
                  Pro2Cmd[5] = VCO_CNT1;
                  Pro2Cmd[6] = VCO_CNT0;
              
                  radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_RX_HOP, Pro2Cmd );
              }
              
              /*!
               * This command is used to allow override of the AGC.
C51 COMPILER V9.51   SI446X_API_LIB                                                        04/26/2015 18:55:45 PAGE 13  

               *
               * @param AGC_OVERRIDE  AGC override parameters.
               */
              void si446x_agc_override(U8 AGC_OVERRIDE)
              {
                Pro2Cmd[0] = SI446X_CMD_ID_AGC_OVERRIDE;
                Pro2Cmd[1] = AGC_OVERRIDE;
              
                radio_comm_SendCmd( SI446X_CMD_ARG_COUNT_AGC_OVERRIDE, Pro2Cmd );
              }
              
              #endif /* RADIO_DRIVER_FULL_SUPPORT */
              
              #endif /* RADIO_DRIVER_EXTENDED_SUPPORT */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    612    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
